use crate::{
    utils::{
        cube_face::cube_face,
        interpolate::{cosine_interpolate, exp_interpolate, power_curve, smoothstep_mid},
        tree_gen::{generate_mahogany_tree, generate_spruce_tree, generate_walnut_tree},
    },
    voxel::VoxelType,
};
use ferrousgl::{GlWindow, Mesh, Shader};
use glam::{IVec3, Mat4, Vec3};
use noise::{NoiseFn, Perlin, PerlinSurflet};
use rand::Rng;

pub struct Chunk {
    pub voxels: Vec<VoxelType>, // Main chunk voxels (size x size x size)
    pub extended_voxels: Vec<VoxelType>, // Extended voxels ((size+2) x (size+2) x (size+2))
    pub mesh: Option<Mesh>,
    pub vertices: Vec<f32>, // CPU-side vertex data (interleaved positions + UVs)
    pub indices: Vec<u32>,  // CPU-side index data
    // --- Add for transparent mesh ---
    pub transparent_mesh: Option<Mesh>,
    pub transparent_vertices: Vec<f32>,
    pub transparent_indices: Vec<u32>,
    // --- end ---
    pub size: usize,
    pub position: (i32, i32, i32),
    pub seed: u32,
    pub(crate) needs_rebuild: bool,
    /// Stores voxels generated by this chunk that are out of bounds (world coords)
    pub out_of_bounds_voxels: Vec<(i32, i32, i32, VoxelType)>,
}

impl Chunk {
    pub fn new(
        x: i32,
        y: i32,
        z: i32,
        size: usize,
        seed: u32,
        pending_voxels: Option<&[(i32, i32, i32, VoxelType)]>,
    ) -> Self {
        let mut chunk = Self {
            voxels: vec![VoxelType::Air; size * size * size],
            extended_voxels: vec![VoxelType::Air; (size + 2) * (size + 2) * (size + 2)],
            mesh: None,
            vertices: Vec::new(),
            indices: Vec::new(),
            transparent_mesh: None,
            transparent_vertices: Vec::new(),
            transparent_indices: Vec::new(),
            size,
            position: (x, y, z),
            seed,
            needs_rebuild: true,
            out_of_bounds_voxels: Vec::new(),
        };

        if let Some(voxels) = pending_voxels {
            chunk.load_voxels_world(voxels);
        }

        chunk
    }

    pub fn get_extended_voxel(&self, x: i32, y: i32, z: i32) -> VoxelType {
        if x < -1
            || y < -1
            || z < -1
            || x > self.size as i32
            || y > self.size as i32
            || z > self.size as i32
        {
            return VoxelType::Air;
        }
        let x = (x + 1) as usize;
        let y = (y + 1) as usize;
        let z = (z + 1) as usize;
        self.extended_voxels[x + (self.size + 2) * (y + (self.size + 2) * z)]
    }

    pub fn set_extended_voxel(&mut self, x: i32, y: i32, z: i32, v: VoxelType) -> bool {
        if x < -1
            || y < -1
            || z < -1
            || x > self.size as i32
            || y > self.size as i32
            || z > self.size as i32
        {
            return false;
        }
        let x = (x + 1) as usize;
        let y = (y + 1) as usize;
        let z = (z + 1) as usize;
        let idx = x + (self.size + 2) * (y + (self.size + 2) * z);
        self.extended_voxels[idx] = v;

        // If this is within the main voxel area, update that too
        if x > 0 && y > 0 && z > 0 && x <= self.size && y <= self.size && z <= self.size {
            let main_idx = self.index(x - 1, y - 1, z - 1);
            self.voxels[main_idx] = v;
        }

        self.needs_rebuild = true;
        true
    }

    // Index for main voxel array
    pub fn index(&self, x: usize, y: usize, z: usize) -> usize {
        x + self.size * (y + self.size * z)
    }

    // Index for extended voxel array (includes neighbors)
    pub fn extended_index(&self, x: usize, y: usize, z: usize) -> usize {
        (x + 1) + (self.size + 2) * ((y + 1) + (self.size + 2) * (z + 1))
    }

    pub fn get_voxel(&self, x: usize, y: usize, z: usize) -> VoxelType {
        self.voxels[self.index(x, y, z)]
    }

    pub fn get_extended_voxel_old(&self, x: usize, y: usize, z: usize) -> VoxelType {
        self.extended_voxels[self.extended_index(x, y, z)]
    }

    pub fn is_empty(&self) -> bool {
        self.vertices.is_empty()
    }

    pub fn is_transparent_empty(&self) -> bool {
        self.transparent_vertices.is_empty()
    }

    pub fn set_voxel(&mut self, x: usize, y: usize, z: usize, v: VoxelType) {
        let idx = self.index(x, y, z);
        self.voxels[idx] = v;
        let ext_idx = self.extended_index(x, y, z);
        self.extended_voxels[ext_idx] = v;
    }

    /// Generates voxel data for both main and extended areas
    /// Stores out-of-bounds voxels in self.out_of_bounds_voxels.
    pub fn generate_data(&mut self, world_x: i32, world_y: i32, world_z: i32) {
        let perlin = Perlin::new(self.seed);
        let height = Perlin::new(self.seed.wrapping_add(16));
        let biome = Perlin::new(self.seed.wrapping_add(32));
        let heat = Perlin::new(self.seed.wrapping_add(64));
        let mut rng = rand::rng();

        self.out_of_bounds_voxels.clear();

        let main_biome_scale = 0.5;

        // First pass: generate solid terrain (stone) and air
        for x in 0..self.size + 2 {
            for y in 0..self.size + 2 {
                for z in 0..self.size + 2 {
                    let wx = (world_x * self.size as i32) + (x as i32 - 1);
                    let wy = (world_y * self.size as i32) + (y as i32 - 1);
                    let wz = (world_z * self.size as i32) + (z as i32 - 1);

                    // Add global height control noise
                    let global_height_scale = 0.001; // Adjust this for larger/smaller features
                    let global_height_factor = -64.0; // Adjust this for stronger/weaker effect
                    let mut height_adjustment = height.get([
                        wx as f64 * global_height_scale,
                        wz as f64 * global_height_scale,
                    ]);
                    height_adjustment = height_adjustment / 2.0 + 0.5; // Normalize to 0..1
                    height_adjustment = height_adjustment * 0.99;
                    height_adjustment = smoothstep_mid(height_adjustment as f32, 32.0) as f64;
                    let adjusted_wy = wy as f64 - (height_adjustment * global_height_factor);

                    // Biome noise calculations (using adjusted_wy where height matters)
                    let mut biome_value1 = biome.get([
                        wx as f64 * 0.003 * main_biome_scale,
                        wz as f64 * 0.003 * main_biome_scale,
                    ]);
                    biome_value1 = biome_value1 / 2.0 + 0.5;
                    let mut biome_value2 = biome.get([
                        wx as f64 * 0.003 * main_biome_scale,
                        wz as f64 * 0.00 * main_biome_scale,
                    ]);
                    biome_value2 = biome_value2 / 2.0 + 0.5;
                    let mut biome_value3 = biome.get([
                        wx as f64 * 0.03 * main_biome_scale,
                        wz as f64 * 0.03 * main_biome_scale,
                    ]);
                    biome_value3 = biome_value3 / 2.0 + 0.5;
                    let biome_value = biome_value1 * 0.5 + biome_value2 * 0.3 + biome_value3 * 0.2;

                    let mut plains_noise = perlin.get([wx as f64 * 0.01, wz as f64 * 0.01]);
                    plains_noise = plains_noise / 2.0 + 0.5;
                    let mut plains_height_controller =
                        height.get([wx as f64 * 0.001, wz as f64 * 0.001]);
                    plains_height_controller = plains_height_controller / 2.0 + 0.5;
                    let plains = plains_noise - (adjusted_wy - 4.0) * 0.03; // Use adjusted_wy

                    let mut mountain_noise = perlin.get([
                        wx as f64 * 0.02 + 456.78,
                        adjusted_wy * 0.003, // Use adjusted_wy
                        wz as f64 * 0.02 + 234.56,
                    ]);
                    mountain_noise = mountain_noise / 2.0 + 0.5;
                    let mut mountain_noise_2 = perlin.get([wx as f64 * 0.001, wz as f64 * 0.001]);
                    mountain_noise_2 = mountain_noise_2 / 2.0 + 0.5;
                    let mut mountain_noise_3 = perlin.get([
                        wx as f64 * 0.06,
                        adjusted_wy * 0.05, // Use adjusted_wy
                        wz as f64 * 0.06,
                    ]) - (adjusted_wy - 4.0) * 0.0056; // Use adjusted_wy
                    mountain_noise_3 = mountain_noise_3 / 2.0 + 0.5;
                    let mountain =
                        (mountain_noise * 0.7 + mountain_noise_2 * 0.6 + mountain_noise_3 * 0.3)
                            - (adjusted_wy - 4.0) * 0.005; // Use adjusted_wy

                    let mut forest_noise = perlin.get([wx as f64 * 0.01, wz as f64 * 0.01]);
                    forest_noise = forest_noise / 2.0 + 0.5;
                    let forest = (forest_noise) - (adjusted_wy - 12.0) * 0.01; // Use adjusted_wy

                    let mut v = if biome_value > 0.4 && biome_value < 0.6 {
                        if plains > 0.0 {
                            VoxelType::Stone
                        } else {
                            VoxelType::Air
                        }
                    } else if biome_value < 0.4 {
                        let biome_blend = (0.4 - biome_value) / 0.4;
                        if cosine_interpolate(
                            plains as f32,
                            mountain as f32,
                            power_curve(biome_blend as f32, 0.3) as f32,
                        ) > 0.0
                        {
                            VoxelType::Stone
                        } else {
                            VoxelType::Air
                        }
                    } else {
                        let biome_blend = (biome_value - 0.6) / 0.4;
                        let blend_amount = power_curve(biome_blend as f32, 0.3) as f32;
                        if cosine_interpolate(
                            plains as f32,
                            forest as f32,
                            power_curve(blend_amount, 1.6),
                        ) > 0.0
                        {
                            VoxelType::Stone
                        } else {
                            VoxelType::Air
                        }
                    };

                    // Place water under y < -32
                    if wy < -16 && v == VoxelType::Air {
                        v = VoxelType::Water;
                    }

                    let ext_idx = x + (self.size + 2) * (y + (self.size + 2) * z);
                    self.extended_voxels[ext_idx] = v;

                    // Only store in main voxels if within bounds
                    if x > 0 && y > 0 && z > 0 && x <= self.size && y <= self.size && z <= self.size
                    {
                        let idx = self.index(x - 1, y - 1, z - 1);
                        self.voxels[idx] = v;
                    }
                }
            }
        }

        // Second pass: replace surface blocks with appropriate types
        for x in 0..self.size + 2 {
            for y in 0..self.size + 2 {
                for z in 0..self.size + 2 {
                    let ext_idx = x + (self.size + 2) * (y + (self.size + 2) * z);
                    if self.extended_voxels[ext_idx] == VoxelType::Stone {
                        // Check if this block is adjacent to air (surface block)
                        let mut is_surface = false;
                        // Check all 6 directions
                        for (dx, dy, dz) in &[
                            (1, 0, 0),
                            (-1, 0, 0),
                            (0, 1, 0),
                            (0, -1, 0),
                            (0, 0, 1),
                            (0, 0, -1),
                        ] {
                            let nx = x as i32 + dx;
                            let ny = y as i32 + dy;
                            let nz = z as i32 + dz;

                            if nx >= 0
                                && ny >= 0
                                && nz >= 0
                                && nx < (self.size + 2) as i32
                                && ny < (self.size + 2) as i32
                                && nz < (self.size + 2) as i32
                            {
                                let neighbor_idx = nx as usize
                                    + (self.size + 2)
                                        * (ny as usize + (self.size + 2) * nz as usize);
                                if self.extended_voxels[neighbor_idx] == VoxelType::Air {
                                    is_surface = true;
                                    break;
                                }
                            } else {
                                // Edge of the chunk - consider it surface
                                is_surface = false;
                                break;
                            }
                        }

                        if is_surface {
                            let wx = (world_x * self.size as i32) + (x as i32 - 1);
                            let wy = (world_y * self.size as i32) + (y as i32 - 1);
                            let wz = (world_z * self.size as i32) + (z as i32 - 1);

                            let mut biome_value1 = biome.get([
                                wx as f64 * 0.003 * main_biome_scale,
                                wz as f64 * 0.003 * main_biome_scale,
                            ]);
                            biome_value1 = biome_value1 / 2.0 + 0.5;
                            let mut biome_value2 = biome.get([
                                wx as f64 * 0.003 * main_biome_scale,
                                wz as f64 * 0.00 * main_biome_scale,
                            ]);
                            biome_value2 = biome_value2 / 2.0 + 0.5;
                            let mut biome_value3 = biome.get([
                                wx as f64 * 0.03 * main_biome_scale,
                                wz as f64 * 0.03 * main_biome_scale,
                            ]);
                            biome_value3 = biome_value3 / 2.0 + 0.5;
                            let biome_value =
                                biome_value1 * 0.5 + biome_value2 * 0.3 + biome_value3 * 0.2;

                            let mut mountain_detail_noise = 0.0;
                            let mut frequency = 0.03;
                            let mut amplitude = 1.0;
                            let persistence = 0.5;

                            for _ in 0..3 {
                                mountain_detail_noise += perlin.get([
                                    wx as f64 * frequency,
                                    wy as f64 * frequency,
                                    wz as f64 * frequency,
                                ]) * amplitude;

                                frequency *= 2.0;
                                amplitude *= persistence;
                            }

                            let mut heat_value_1 = heat.get([wx as f64 * 0.001, wz as f64 * 0.001]);
                            heat_value_1 = heat_value_1 / 2.0 + 0.5;
                            let mut heat_value_2 = heat.get([wx as f64 * 0.01, wz as f64 * 0.01]);
                            heat_value_2 = heat_value_2 / 2.0 + 0.5;
                            let mut heat_value_3 = heat.get([wx as f64 * 0.1, wz as f64 * 0.1]);
                            heat_value_3 = heat_value_3 / 2.0 + 0.5;

                            let heat_value =
                                heat_value_1 * 0.7 + heat_value_2 * 0.2 + heat_value_3 * 0.1;

                            if biome_value > 0.4 && biome_value < 0.6 {
                                // grass
                                if heat_value < 0.55 {
                                    self.extended_voxels[ext_idx] = VoxelType::Grass;
                                } else {
                                    self.extended_voxels[ext_idx] = VoxelType::Sand;
                                }
                            } else if biome_value < 0.4 {
                                // mountains
                                let snow_probability = if wy < 50 {
                                    if rng.random_bool(0.01) {
                                        let tree_voxels = generate_spruce_tree((wx, wy + 1, wz));
                                        for (tx, ty, tz, vtype) in tree_voxels {
                                            let lx = tx - world_x * self.size as i32;
                                            let ly = ty - world_y * self.size as i32;
                                            let lz = tz - world_z * self.size as i32;
                                            if lx < 0
                                                || lx >= self.size as i32
                                                || ly < 0
                                                || ly >= self.size as i32
                                                || lz < 0
                                                || lz >= self.size as i32
                                            {
                                                self.out_of_bounds_voxels.push((tx, ty, tz, vtype));
                                            } else {
                                                let idx = self.index(
                                                    lx as usize,
                                                    ly as usize,
                                                    lz as usize,
                                                );
                                                self.voxels[idx] = vtype;
                                                let ext_idx = self.extended_index(
                                                    lx as usize,
                                                    ly as usize,
                                                    lz as usize,
                                                );
                                                self.extended_voxels[ext_idx] = vtype;
                                            }
                                        }
                                    }
                                    0.0
                                } else if wy > 100 {
                                    1.0
                                } else {
                                    (wy - 50) as f32 / 30.0 // Linear increase from 0 to 1 between Y=80 and Y=100
                                };

                                // Random chance based on snow probability
                                if rng.random_range(0.0..1.0) < snow_probability {
                                    if mountain_detail_noise > 0.0 {
                                        self.extended_voxels[ext_idx] = VoxelType::Snow // Changed from Gravel to Snow
                                    } else {
                                        self.extended_voxels[ext_idx] = VoxelType::Ice // Changed from Stone to Ice
                                    }
                                } else {
                                    if mountain_detail_noise > 0.3333 {
                                        self.extended_voxels[ext_idx] = VoxelType::Gravel
                                    } else if mountain_detail_noise < -0.3333 {
                                        self.extended_voxels[ext_idx] = VoxelType::Grass
                                    } else {
                                        self.extended_voxels[ext_idx] = VoxelType::Stone
                                    }
                                }
                            } else {
                                // forest
                                if heat_value < 0.575 {
                                    self.extended_voxels[ext_idx] = VoxelType::Grass;

                                    if heat_value < 0.575
                                        && biome_value > 0.6
                                        && rng.random_bool(0.05)
                                    {
                                        generate_walnut_tree((wx, wy + 1, wz))
                                            .into_iter()
                                            .for_each(|(tx, ty, tz, vtype)| {
                                                let lx = tx - world_x * self.size as i32;
                                                let ly = ty - world_y * self.size as i32;
                                                let lz = tz - world_z * self.size as i32;
                                                if lx < 0
                                                    || lx >= self.size as i32
                                                    || ly < 0
                                                    || ly >= self.size as i32
                                                    || lz < 0
                                                    || lz >= self.size as i32
                                                {
                                                    self.out_of_bounds_voxels
                                                        .push((tx, ty, tz, vtype));
                                                } else {
                                                    let idx = self.index(
                                                        lx as usize,
                                                        ly as usize,
                                                        lz as usize,
                                                    );
                                                    self.voxels[idx] = vtype;
                                                    let ext_idx = self.extended_index(
                                                        lx as usize,
                                                        ly as usize,
                                                        lz as usize,
                                                    );
                                                    self.extended_voxels[ext_idx] = vtype;
                                                }
                                            });
                                    }
                                } else {
                                    self.extended_voxels[ext_idx] = VoxelType::Grass;

                                    if heat_value > 0.575
                                        && biome_value > 0.6
                                        && rng.random_bool(0.005)
                                    {
                                        generate_mahogany_tree((wx, wy + 1, wz))
                                            .into_iter()
                                            .for_each(|(tx, ty, tz, vtype)| {
                                                let lx = tx - world_x * self.size as i32;
                                                let ly = ty - world_y * self.size as i32;
                                                let lz = tz - world_z * self.size as i32;
                                                if lx < 0
                                                    || lx >= self.size as i32
                                                    || ly < 0
                                                    || ly >= self.size as i32
                                                    || lz < 0
                                                    || lz >= self.size as i32
                                                {
                                                    self.out_of_bounds_voxels
                                                        .push((tx, ty, tz, vtype));
                                                } else {
                                                    let idx = self.index(
                                                        lx as usize,
                                                        ly as usize,
                                                        lz as usize,
                                                    );
                                                    self.voxels[idx] = vtype;
                                                    let ext_idx = self.extended_index(
                                                        lx as usize,
                                                        ly as usize,
                                                        lz as usize,
                                                    );
                                                    self.extended_voxels[ext_idx] = vtype;
                                                }
                                            });
                                    }
                                }
                            }

                            // Update main voxels if within bounds
                            if x > 0
                                && y > 0
                                && z > 0
                                && x <= self.size
                                && y <= self.size
                                && z <= self.size
                            {
                                let idx = self.index(x - 1, y - 1, z - 1);
                                self.voxels[idx] = self.extended_voxels[ext_idx];
                            }
                        }
                    }
                }
            }
        }
    }

    /// Prepares mesh data on CPU using extended voxel information
    // chunk.rs
    pub fn prepare_mesh(&mut self) {
        self.vertices.clear();
        self.indices.clear();
        self.transparent_vertices.clear();
        self.transparent_indices.clear();

        let mut positions = Vec::new();
        let mut uvs = Vec::new();
        let mut normals = Vec::new(); // New: for normal vectors
        let mut trans_positions = Vec::new();
        let mut trans_uvs = Vec::new();
        let mut trans_normals = Vec::new(); // New: for transparent normal vectors

        // Predefined face normals
        const FACE_NORMALS: [[f32; 3]; 6] = [
            [0.0, 1.0, 0.0],  // Top
            [0.0, -1.0, 0.0], // Bottom
            [0.0, 0.0, 1.0],  // Front
            [0.0, 0.0, -1.0], // Back
            [1.0, 0.0, 0.0],  // Right
            [-1.0, 0.0, 0.0], // Left
        ];

        for x in 1..=self.size {
            for y in 1..=self.size {
                for z in 1..=self.size {
                    let voxel = self.extended_voxels[self.extended_index(x - 1, y - 1, z - 1)];
                    if voxel == VoxelType::Air {
                        continue;
                    }

                    if voxel.is_transparent() {
                        if voxel.transparent_optimize_outer_only() {
                            // Special handling for water - only outline edges
                            for (dx, dy, dz, face) in [
                                (0, 1, 0, 0),  // Top
                                (0, -1, 0, 1), // Bottom
                                (0, 0, 1, 2),  // Front
                                (0, 0, -1, 3), // Back
                                (1, 0, 0, 4),  // Right
                                (-1, 0, 0, 5), // Left
                            ] {
                                let nx = x as isize + dx;
                                let ny = y as isize + dy;
                                let nz = z as isize + dz;

                                let neighbor = self.extended_voxels[nx as usize
                                    + (self.size + 2)
                                        * (ny as usize + (self.size + 2) * nz as usize)];

                                if !neighbor.transparent_optimize_outer_only() {
                                    let local_x = x - 1;
                                    let local_y = y - 1;
                                    let local_z = z - 1;

                                    let (face_verts, face_uvs) = cube_face(
                                        local_x,
                                        local_y,
                                        local_z,
                                        voxel.get_face_texture(face),
                                        face,
                                    );
                                    trans_positions.extend_from_slice(&face_verts);
                                    trans_uvs.extend_from_slice(&face_uvs);
                                    // Add normal for each vertex in this face (4 vertices)
                                    for _ in 0..4 {
                                        trans_normals.extend_from_slice(&FACE_NORMALS[face]);
                                    }
                                }
                            }
                        }
                        if voxel.transparent_optimize_outer_one_inner() {
                            // Other transparent blocks - render all faces if adjacent to air
                            let mut adjacent_to_air = false;
                            for (dx, dy, dz) in [
                                (0, 1, 0),  // Top
                                (0, -1, 0), // Bottom
                                (0, 0, 1),  // Front
                                (0, 0, -1), // Back
                                (1, 0, 0),  // Right
                                (-1, 0, 0), // Left
                            ] {
                                let nx = x as isize + dx;
                                let ny = y as isize + dy;
                                let nz = z as isize + dz;

                                let neighbor = self.extended_voxels[nx as usize
                                    + (self.size + 2)
                                        * (ny as usize + (self.size + 2) * nz as usize)];

                                if neighbor == VoxelType::Air {
                                    adjacent_to_air = true;
                                    break;
                                }
                            }

                            if adjacent_to_air {
                                let local_x = x - 1;
                                let local_y = y - 1;
                                let local_z = z - 1;

                                for face in 0..6 {
                                    let (face_verts, face_uvs) = cube_face(
                                        local_x,
                                        local_y,
                                        local_z,
                                        voxel.get_face_texture(face),
                                        face,
                                    );
                                    trans_positions.extend_from_slice(&face_verts);
                                    trans_uvs.extend_from_slice(&face_uvs);
                                    // Add normal for each vertex in this face (4 vertices)
                                    for _ in 0..4 {
                                        trans_normals.extend_from_slice(&FACE_NORMALS[face]);
                                    }
                                }
                            }
                        }
                    } else {
                        // Opaque voxels - normal face culling
                        for (dx, dy, dz, face) in [
                            (0, 1, 0, 0),  // Top
                            (0, -1, 0, 1), // Bottom
                            (0, 0, 1, 2),  // Front
                            (0, 0, -1, 3), // Back
                            (1, 0, 0, 4),  // Right
                            (-1, 0, 0, 5), // Left
                        ] {
                            let nx = x as isize + dx;
                            let ny = y as isize + dy;
                            let nz = z as isize + dz;

                            let neighbor = self.extended_voxels[nx as usize
                                + (self.size + 2) * (ny as usize + (self.size + 2) * nz as usize)];

                            if neighbor == VoxelType::Air || neighbor.is_transparent() {
                                let local_x = x - 1;
                                let local_y = y - 1;
                                let local_z = z - 1;

                                let (face_verts, face_uvs) = cube_face(
                                    local_x,
                                    local_y,
                                    local_z,
                                    voxel.get_face_texture(face),
                                    face,
                                );
                                positions.extend_from_slice(&face_verts);
                                uvs.extend_from_slice(&face_uvs);
                                // Add normal for each vertex in this face (4 vertices)
                                for _ in 0..4 {
                                    normals.extend_from_slice(&FACE_NORMALS[face]);
                                }
                            }
                        }
                    }
                }
            }
        }

        // Interleave positions, normals, and UVs into vertices vector
        self.vertices.reserve(positions.len() * 8); // 3 pos + 3 normal + 2 uv

        // Ensure normals are in chunks of 3
        let normal_chunks = normals.chunks_exact(3);
        for ((pos, normal), uv) in positions.iter().zip(normal_chunks).zip(uvs.iter()) {
            self.vertices.extend_from_slice(&[
                pos[0], pos[1], pos[2], // position
                normal[0], normal[1], normal[2], // normal
                uv[0], uv[1], // texture coord
            ]);
        }

        // Same for transparent vertices
        self.transparent_vertices.reserve(trans_positions.len() * 8);
        let trans_normal_chunks = trans_normals.chunks_exact(3);
        for ((pos, normal), uv) in trans_positions
            .iter()
            .zip(trans_normal_chunks)
            .zip(trans_uvs.iter())
        {
            self.transparent_vertices.extend_from_slice(&[
                pos[0], pos[1], pos[2], // position
                normal[0], normal[1], normal[2], // normal
                uv[0], uv[1], // texture coord
            ]);
        }

        // Generate indices (unchanged)
        self.indices.reserve((self.vertices.len() / 32) * 6); // Changed divisor from 20 to 32 (8 floats per vertex)
        for i in 0..(self.vertices.len() / 32) {
            let base = (i * 4) as u32;
            self.indices
                .extend_from_slice(&[base, base + 1, base + 2, base, base + 2, base + 3]);
        }

        self.transparent_indices
            .reserve((self.transparent_vertices.len() / 32) * 6);
        for i in 0..(self.transparent_vertices.len() / 32) {
            let base = (i * 4) as u32;
            self.transparent_indices.extend_from_slice(&[
                base,
                base + 1,
                base + 2,
                base,
                base + 2,
                base + 3,
            ]);
        }
    }

    pub fn upload_to_gpu(&mut self) {
        // Create mesh if it doesn't exist
        if self.mesh.is_none() {
            self.mesh = Some(Mesh::new());
        }
        if self.transparent_mesh.is_none() {
            self.transparent_mesh = Some(Mesh::new());
        }

        let mesh = self.mesh.as_mut().unwrap();

        mesh.add_vertex_attributes(&[
            (0, 3, gl::FLOAT, false), // position
            (1, 3, gl::FLOAT, false), // normal (new)
            (2, 2, gl::FLOAT, false), // texture coord (changed from 1 to 2)
        ]);

        mesh.update_indices(&self.indices);
        mesh.update_vertices(&self.vertices);

        // --- Transparent mesh upload ---
        let tmesh = self.transparent_mesh.as_mut().unwrap();
        tmesh.add_vertex_attributes(&[
            (0, 3, gl::FLOAT, false), // position
            (1, 3, gl::FLOAT, false), // normal (new)
            (2, 2, gl::FLOAT, false), // texture coord
        ]);
        tmesh.update_indices(&self.transparent_indices);
        tmesh.update_vertices(&self.transparent_vertices);
        // --- end ---

        self.needs_rebuild = false;
    }

    pub fn render(&self, window: &GlWindow, shader: &Shader) {
        if let Some(mesh) = &self.mesh {
            let model = Mat4::from_translation(Vec3::new(
                self.position.0 as f32 * self.size as f32,
                self.position.1 as f32 * self.size as f32,
                self.position.2 as f32 * self.size as f32,
            ));

            shader.set_uniform_matrix_4fv("model", model.as_ref());
            window.render_mesh(mesh);
        }
    }

    pub fn render_transparent(&self, window: &GlWindow, shader: &Shader) {
        if let Some(mesh) = &self.transparent_mesh {
            let model = Mat4::from_translation(Vec3::new(
                self.position.0 as f32 * self.size as f32,
                self.position.1 as f32 * self.size as f32,
                self.position.2 as f32 * self.size as f32,
            ));

            shader.set_uniform_matrix_4fv("model", model.as_ref());
            window.render_mesh(mesh);
        }
    }

    /// Loads a list of voxels into the chunk using world coordinates.
    /// Each voxel is a tuple: (world_x, world_y, world_z, VoxelType).
    /// Voxels not in this chunk are ignored.
    pub fn load_voxels_world(&mut self, voxels: &[(i32, i32, i32, VoxelType)]) {
        let (chunk_x, chunk_y, chunk_z) = self.position;
        let size = self.size as i32;

        for &(wx, wy, wz, v) in voxels {
            let local_x = wx - chunk_x * size;
            let local_y = wy - chunk_y * size;
            let local_z = wz - chunk_z * size;

            if local_x >= 0
                && local_x < size
                && local_y >= 0
                && local_y < size
                && local_z >= 0
                && local_z < size
            {
                self.set_voxel(local_x as usize, local_y as usize, local_z as usize, v);
            }
        }
    }
}
